// PTO Ascend A2/A3 Cycle-Accurate Simulator
// Auto-generated by PTO ISA Compiler
// 
// This code uses the A2A3 Core Simulator for cycle-accurate InCore execution.
// InCore functions contain actual Ascend instructions that are parsed and
// simulated by the core model.

// POSIX definitions must come FIRST, before ANY system includes
// This enables clock_gettime, nanosleep, etc.
#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 199309L
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <time.h>

// Enable A2A3 platform for dual-queue simulation
#define PTO_PLATFORM_A2A3
#define A2A3_TARGET_SIMULATOR

// Include PTO runtime with simulation support
#include "pto_runtime.h"
#include "pto_runtime.c"

// Include A2A3 Core Simulator (for cycle-accurate simulation)
// Note: The core simulator is linked separately as liba2a3_core.a
// If not available, we fall back to heuristic cycle estimation

#ifdef A2A3_CORE_SIM_AVAILABLE
#include "runtime_a2a3_sim/core_model/a2a3_core_model.h"
#include "runtime_a2a3_sim/core_model/a2a3_incore_sim.h"
#endif



// =============================================================================
// InCore Function Registry (for Core Simulator)
// =============================================================================

#ifdef A2A3_CORE_SIM_AVAILABLE
static IncoreSimulator* g_incore_sim = NULL;

void init_incore_simulator(void) {
    if (!g_incore_sim) {
        g_incore_sim = a2a3_incore_sim_create();
    }
}

void cleanup_incore_simulator(void) {
    if (g_incore_sim) {
        a2a3_incore_sim_destroy(g_incore_sim);
        g_incore_sim = NULL;
    }
}

// Get cycle cost using core simulator
int64_t get_incore_cycle_cost_sim(const char* func_name, int64_t tile_size) {
    if (g_incore_sim) {
        return a2a3_incore_sim_execute_by_name(g_incore_sim, func_name);
    }
    return a2a3_get_incore_cycle_cost(func_name, tile_size);
}
#else
// Fallback when core simulator not available
void init_incore_simulator(void) {}
void cleanup_incore_simulator(void) {}

int64_t get_incore_cycle_cost_sim(const char* func_name, int64_t tile_size) {
    // Heuristic estimation based on function name
    if (strstr(func_name, "matmul") || strstr(func_name, "gemm")) return 50;
    if (strstr(func_name, "rmsnorm") || strstr(func_name, "layernorm")) return 70;
    if (strstr(func_name, "softmax")) return 70;
    if (strstr(func_name, "rope")) return 60;
    if (strstr(func_name, "swiglu") || strstr(func_name, "silu")) return 25;
    if (strstr(func_name, "attention") || strstr(func_name, "score")) return 60;
    if (strstr(func_name, "rowsum") || strstr(func_name, "rowmax")) return 20;
    if (strstr(func_name, "add") || strstr(func_name, "mul")) return 10;
    if (strstr(func_name, "exp") || strstr(func_name, "sqrt")) return 10;
    return 10;  // Default
}
#endif



// =============================================================================
// Orchestration Function: bgemm_dynamic
// Generates task graph for Ascend A2/A3 cycle-accurate simulation
// =============================================================================
//
// Parameters passed via void** array:
//   [0] A (float*)
//   [1] B (float*)
//   [2] C (float*)
//   [3] b (int32_t)
//   [4] m (int32_t)
//   [5] k (int32_t)
//   [6] n (int32_t)
//
// Intermediate buffers (Mode B - runtime allocated):
//   P: 16384 bytes (allocated by runtime)
// =============================================================================

void bgemm_dynamic(PTORuntime* rt, void* user_data) {
    // Unpack parameters from void** array
    void** params = (void**)user_data;
    (void)params;  // Suppress unused warning if no params

    float* A = (float*)params[0];
    float* B = (float*)params[1];
    float* C = (float*)params[2];
    int32_t b = *(int32_t*)params[3];
    int32_t m = *(int32_t*)params[4];
    int32_t k = *(int32_t*)params[5];
    int32_t n = *(int32_t*)params[6];

    // Intermediate buffers (Mode B: runtime-allocated)
    // These variables receive allocated addresses from runtime during task submission
    void* P = NULL;  // Size: 16384 bytes

    // Root scope for buffer lifetime management
    pto_scope_begin(rt);

    int32_t _task_id = 0;

    for (int batch = 0; batch < b; batch += 1) {
        for (int sm = 0; sm < m; sm += 4) {
            for (int sn = 0; sn < n; sn += 4) {
                for (int k_idx = 0; k_idx < k; k_idx += 1) {
                    for (int lm = 0; lm < 4; lm += 1) {
                        for (int ln = 0; ln < 4; ln += 1) {
                            // Task: gemm_tile (Cube Core)
                            {
                                int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
                                pto_task_add_input(rt, t, A, batch * (m * k) + (sm + lm) * k + k_idx, 0, 32, 128);
                                pto_task_add_input(rt, t, B, batch * (k * n) + k_idx * n + (sn + ln), 0, 32, 128);
                                pto_task_add_output_ref(rt, t, &P, 0, 0, 32, 128);
                                // Cycle cost: 10 (heuristic), use core sim for accurate timing
                                pto_task_submit(rt, t);
                            }

                            // Task: tile_add (Vector Core)
                            {
                                int32_t t = pto_task_alloc(rt, "tile_add", NULL, 0, 0, false);
                                pto_task_add_input(rt, t, C, batch * (m * n) + (sm + lm) * n + (sn + ln), 0, 32, 128);
                                pto_task_add_input(rt, t, P, 0, 0, 32, 128);
                                pto_task_add_output(rt, t, C, batch * (m * n) + (sm + lm) * n + (sn + ln), 0, 32, 128);
                                // Cycle cost: 10 (heuristic), use core sim for accurate timing
                                pto_task_submit(rt, t);
                            }

                        }
                    }
                }
            }
        }
    }
    __pto_orch_epilogue:;
    pto_scope_end(rt);
    return;
}

// =============================================================================
// Main Function for Cycle-Accurate Simulation
// =============================================================================
// Usage: bgemm_dynamic [--benchmark-only] [b] [m] [k] [n]
// Flags:
//   --benchmark-only  - Only run orchestration (skip simulation), output stats
// Environment variables:
//   PTO_TRACE_OUTPUT=file - Output trace file path

int main(int argc, char** argv) {
    // Check for --benchmark-only flag
    int benchmark_only = 0;
    int arg_offset = 0;
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--benchmark-only") == 0) {
            benchmark_only = 1;
            arg_offset = 1;
            break;
        }
    }
    
    if (!benchmark_only) {
        printf("=== Ascend A2/A3 Cycle-Accurate Simulator ===\n");
        printf("    Platform: Ascend 910B (A2/A3)\n");
        printf("    Workers:  %d vector + %d cube\n", 
               A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
#ifdef A2A3_CORE_SIM_AVAILABLE
        printf("    Core Sim: Enabled (cycle-accurate)\n\n");
#else
        printf("    Core Sim: Disabled (using heuristics)\n\n");
#endif
    }
    
    // Initialize InCore simulator
    init_incore_simulator();
    
    // Initialize runtime (heap allocated due to large size)
    PTORuntime* rt = (PTORuntime*)calloc(1, sizeof(PTORuntime));
    if (!rt) {
        fprintf(stderr, "Failed to allocate runtime\n");
        return 1;
    }
    pto_runtime_init(rt);
    
    // Enable A2A3 simulation with platform-defined worker configuration
    // A2A3 (Ascend 910B): 48 vector workers + 24 cube workers
    pto_runtime_enable_a2a3_sim(rt, A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
    
    // Allocate test data
    float* A = (float*)calloc(1024 * 1024, sizeof(float));
    float* B = (float*)calloc(1024 * 1024, sizeof(float));
    float* C = (float*)calloc(1024 * 1024, sizeof(float));
    int32_t b = 16;  // Default
    int32_t m = 16;  // Default
    int32_t k = 16;  // Default
    int32_t n = 16;  // Default

    // Parse command line arguments for scalar parameters (with offset for --benchmark-only flag)
    if (argc > 1 + arg_offset) b = atoi(argv[1 + arg_offset]);
    if (argc > 2 + arg_offset) m = atoi(argv[2 + arg_offset]);
    if (argc > 3 + arg_offset) k = atoi(argv[3 + arg_offset]);
    if (argc > 4 + arg_offset) n = atoi(argv[4 + arg_offset]);

    // Set up parameter array (void** for orchestration function)
    void* user_data[7];
    user_data[0] = (void*)A;
    user_data[1] = (void*)B;
    user_data[2] = (void*)C;
    user_data[3] = (void*)&b;
    user_data[4] = (void*)&m;
    user_data[5] = (void*)&k;
    user_data[6] = (void*)&n;

    // Print configuration
    if (!benchmark_only) {
        printf("Configuration:\n");
        printf("  b = %d\n", b);
        printf("\nPhase 1: Building task graph...\n");
    }
    
    // Set runtime mode to SIMULATE for flow control testing
    // This enables blocking wait when ring buffers are full
    pto_runtime_set_mode(rt, PTO_MODE_SIMULATE);
    
    // === BENCHMARK: Measure orchestration time ===
    struct timespec start_time, end_time;
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    // Call orchestration function to build task graph (using void** interface)
    bgemm_dynamic(rt, (void*)user_data);
    
    clock_gettime(CLOCK_MONOTONIC, &end_time);
    double orch_time_ms = (end_time.tv_sec - start_time.tv_sec) * 1000.0 +
                          (end_time.tv_nsec - start_time.tv_nsec) / 1000000.0;
    // === END BENCHMARK ===
    
    int64_t tasks_submitted = rt->total_tasks_scheduled;
    
    if (benchmark_only) {
        // Benchmark mode: just output stats in parseable format
        double tasks_per_ms = tasks_submitted / orch_time_ms;
        printf("BENCHMARK: b=%d tasks=%lld time_ms=%.3f tasks_per_ms=%.2f\n",
               b, (long long)tasks_submitted, orch_time_ms, tasks_per_ms);
    } else {
        printf("  Submitted %lld tasks\n", (long long)tasks_submitted);
        printf("  Orchestration time: %.3f ms (%.2f tasks/ms)\n", 
               orch_time_ms, tasks_submitted / orch_time_ms);
        
        // Dump task graph before simulation
#ifdef PTO_TASK_DUMP
        pto_runtime_dump(rt, "bgemm_dynamic_task_graph.txt");
#endif
        
        printf("\nPhase 2: Running cycle-accurate simulation...\n");
        
        // Run cycle-accurate simulation
        pto_simulate_all(rt);
        
        // Print cycle trace summary
        pto_trace_print_summary();
        
        // Print flow control statistics
        pto_print_flow_stats(rt);
        
        // Print flow control statistics
        pto_print_flow_stats(rt);
        
        // Save trace to JSON for visualization
        const char* trace_file = getenv("PTO_TRACE_OUTPUT");
        if (!trace_file) {
            trace_file = "trace.json";
        }
        pto_trace_write_json(trace_file);
        printf("Trace saved to: %s\n", trace_file);
        printf("  Open in Chrome: chrome://tracing and load the file\n");
    }
    
    // Shutdown and free resources
    pto_runtime_shutdown(rt);
    free(rt);
    cleanup_incore_simulator();
    
    // Free test data
    free(A);
    free(B);
    free(C);
    
    if (!benchmark_only) {
        printf("\n=== Simulation Complete ===\n");
    }
    return 0;
}
